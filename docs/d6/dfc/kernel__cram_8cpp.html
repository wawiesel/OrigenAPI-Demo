<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>ORIGEN API: Solver/cram/src/kernel_cram.cpp File Reference</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">ORIGEN API v0.5.2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Overview</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../modules.html"><span>Components</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../d1/d5b/md__c_h_a_n_g_e_l_o_g.html"><span>Changelog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_bbfb5cf133b5ee2ba5207ad49be3b96c.html">Solver</a></li><li class="navelem"><a class="el" href="../../dir_8f3cde3fac723e4552b5504cffd18f9b.html">cram</a></li><li class="navelem"><a class="el" href="../../dir_6d6fe34b92091976de4942a550a86094.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kernel_cram.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CRAM depletion solver.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="../../da/def/kernel__cram_8hpp.html">Origen/Solver/cram/src/kernel_cram.hpp</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;ctime&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;ScaleUtils/SuperLU/SRC/slu_zdefs.h&quot;</code><br />
<code>#include &quot;Standard/Interface/jdebug.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af2e1575f3f81b75079edded741a589e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#af2e1575f3f81b75079edded741a589e3">SORT_NUCLIDES</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:af2e1575f3f81b75079edded741a589e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730144db7cae69370cb69bd1a67db8ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a730144db7cae69370cb69bd1a67db8ae">MAKE_EXPM_INPUT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a730144db7cae69370cb69bd1a67db8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba87788653e245f06fb028f5a7f6897"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a5ba87788653e245f06fb028f5a7f6897">MAKE_MATLAB_INPUT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a5ba87788653e245f06fb028f5a7f6897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2e62c0dbebc787052c165afcada0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a47f2e62c0dbebc787052c165afcada0e">NAME</a>&#160;&#160;&#160;&quot;Origen/Manager/Wrapper/kernel_cram.cpp&quot;</td></tr>
<tr class="memdesc:a47f2e62c0dbebc787052c165afcada0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for error messages.  <a href="#a47f2e62c0dbebc787052c165afcada0e">More...</a><br /></td></tr>
<tr class="separator:a47f2e62c0dbebc787052c165afcada0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a246b07e575efe303e340da78c4e3e15c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a246b07e575efe303e340da78c4e3e15c">CopyLU</a> (SuperMatrix *L, SuperMatrix *U, LUstore *LU)</td></tr>
<tr class="separator:a246b07e575efe303e340da78c4e3e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5a005e75ba1c528c5f8597d45cb1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#aff5a005e75ba1c528c5f8597d45cb1cb">makeExpmInput</a> (int itot, int a_n, int nnz, doublecomplex *a_val_complex, int *a_ci, int *rp, double delta_t, doublecomplex *Bvals, double **source_term, int source_order, int *ZAI)</td></tr>
<tr class="separator:aff5a005e75ba1c528c5f8597d45cb1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8109e19dd4e4009213d14ae3d68214f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a8109e19dd4e4009213d14ae3d68214f5">makeMatlabInput</a> (int itot, int a_n, doublecomplex *a_val_complex, int *a_ci, int *a_rp, int *ZAI)</td></tr>
<tr class="separator:a8109e19dd4e4009213d14ae3d68214f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce670e6925467c50c380d67ffe4dbd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a9ce670e6925467c50c380d67ffe4dbd7">sortCRSnuclides</a> (int a_n, int a_nnz, double **a_val, int **a_ci, int **a_rp, int *newIdx, int *oldIdx, int sort_nuclides, int *ZAI)</td></tr>
<tr class="separator:a9ce670e6925467c50c380d67ffe4dbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280cd76fe988677c00f96930b194e4a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram</a> (double *n_out, double *n0, double **source_term, int source_order, double delta_t, int itot, int non, int *non0, int *kd, double *diag, double *offdiag, int *loc, int zero_flux_step, int is_adjoint, int cram_order, int internal_steps, int remove_negatives, double cutoff, int *ZAI)</td></tr>
<tr class="separator:a280cd76fe988677c00f96930b194e4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766915c86655672579fe5205b19bc692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a766915c86655672579fe5205b19bc692">OrigenToCRSMatrix</a> (int *p_a_n, double **p_a_val, int **p_a_ci, int **p_a_rp, int **p_a_diag_idx, int *p_a_nnz, int **p_newIdx, int **p_oldIdx, double **p_src_dummy_n0, int itot, int non, int *non0, int *kd, double *diag, double *offdiag, int *loc, double **source_term, int source_order, int zero_flux_step, int is_adjoint, int sort_nuclides, int *ZAI)</td></tr>
<tr class="separator:a766915c86655672579fe5205b19bc692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CRAM depletion solver. </p>
<dl class="section author"><dt>Author</dt><dd>Aarno Isotalo </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="af2e1575f3f81b75079edded741a589e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SORT_NUCLIDES&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort nuclides if ZAI is provided (logical int). Sorting improves performance by factor of 2. Unless problems arise this should always be on. </p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="a730144db7cae69370cb69bd1a67db8ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_EXPM_INPUT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls printing of input for an external test program. For internal testing purposes only. 0 = not printed, 1 = print with separate source, 2 = print with source merged to the matrix with dummy elements </p>

<p>Referenced by <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#aff5a005e75ba1c528c5f8597d45cb1cb">makeExpmInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba87788653e245f06fb028f5a7f6897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_MATLAB_INPUT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls printing of the matrix in matlab form (logical int). For internal testing purposes only. </p>

<p>Referenced by <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a8109e19dd4e4009213d14ae3d68214f5">makeMatlabInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a47f2e62c0dbebc787052c165afcada0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NAME&#160;&#160;&#160;&quot;Origen/Manager/Wrapper/kernel_cram.cpp&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifier for error messages. </p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a246b07e575efe303e340da78c4e3e15c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CopyLU </td>
          <td>(</td>
          <td class="paramtype">SuperMatrix *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SuperMatrix *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LUstore *&#160;</td>
          <td class="paramname"><em>LU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special fun fun copy the L and U matrices in SuperLU format.</p>
<p>This copies the pointers, not their contents. New Store is allocated. nzval (the non-zero values) pointers are also copied but then the nzval pointers in L U are set to point to new, freshly allocated memory. This way the data from L, U is now in LU without copying any memory. nzval in L, U are effectively reset, but they are not needed anyway (L,U are used to store the next LU decomposition for different pole in CRAM so nzval would be overwritten anyway.</p>
<p>Because the pointers, rather than the memory they point to is copied, all copies (except nzval) end up pointing to the same space, i.e., the "work" array in the solver. This works because Every A and thus every L, U has the same sparsity pattern.</p>
<p>The first pair of nzval (for term k=0) will point to work while the rest will point to the new arrays allocated on the previous k in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="aff5a005e75ba1c528c5f8597d45cb1cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeExpmInput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>a_val_complex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>a_ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>a_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>Bvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the CRS matrix to a format used by an external test program "expm". This function exists for development purposes only. The input is written to file "expmInput" in current directory. </p>

<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a730144db7cae69370cb69bd1a67db8ae">MAKE_EXPM_INPUT</a>, and <a class="el" href="../../d8/dc8/_fake_factory_8cpp.html#a6deea1c2ba17f0529b284f5013940b9f">r</a>.</p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="a8109e19dd4e4009213d14ae3d68214f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeMatlabInput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>a_val_complex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>a_ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>a_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the matrix and ZAI to a .m file </p>

<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a5ba87788653e245f06fb028f5a7f6897">MAKE_MATLAB_INPUT</a>, and <a class="el" href="../../d8/dc8/_fake_factory_8cpp.html#a6deea1c2ba17f0529b284f5013940b9f">r</a>.</p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce670e6925467c50c380d67ffe4dbd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sortCRSnuclides </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>p_a_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>oldIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort_nuclides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts nuclides in a CRS matrix decay/transmutation system by ascending ZAI.</p>
<p>Input is a CRS matrix and a ZAI array. ZAI can be nullptr in which case sorting is not performed. The oldIdx and newIdx arrays are generated either way (they are trivial if no sorting was done).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_n</td><td>Size of the CRS matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nnz</td><td>Number of elements in CRS matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_a_val[a_nnz]</td><td>Non-zero elements of CRS matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_a_ci[a_nnz]</td><td>Column indices of CRS matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_a_rp[itot+1]</td><td>Row pointers of CRS matrix A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oldIdx[itot]</td><td>oldIdx[i] is the old index of the nuclide that has new index i </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx[itot]</td><td>newIdx[i] is the new index of the nuclide that had old index i </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sort_nuclides</td><td>Logical, whether to actually sort the nuclides </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZAI[itot]</td><td>ZAI identifiers of the nuclides. Can be nullptr in which case sorting is not actually done. (Still needs to be called to set the index arrays.) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a17888fff360262af994463a57b69e1a3">OrigenToCRSMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a280cd76fe988677c00f96930b194e4a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kernel_cram </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>non0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zero_flux_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cram_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>internal_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CRAM depletion solver with source term and adjoint capabilities.</p>
<p>Based on the publication: Pusa, M. and Lepp√§nen, J. "Computing the matrix exponential in burnup
  calculations." Nucl. Sci. Eng., 164 (2010) 140-150.</p>
<p>The required linear system solutions are done with the SuperLU library: Xiaoye S. Li. "An Overview of {SuperLU}: Algorithms, Implementation, and
  User Interface." ACM Trans.Math. Softw., 31;3 (2005) 302-325.</p>
<p><b>Fortran</b> should call <a class="el" href="../../da/def/kernel__cram_8hpp.html#aa519e485bd96a0c81aa4d4fd56b96926">kernel_cram_from_fortran()</a> instead.</p>
<p><b>Source term</b> can have polynomial time dependency. Due to numerical issues source order is limited to cram_order/2-2. Non constant source term will cause some deterioration in accuracy, but below this limit it should be negligible.</p>
<p><b>Adjoint calculation</b> is also possible by passing is_adjoint=1. In adjoint mode n0, source_term and delta_t&gt;0 must be those for the adjoint problem while everything else must have values defining the forward system.</p>
<p><b>Internal substeps:</b> Dividin steps to pieces greatly improved accuracy. This is particularly significant for decay problems where accuracy without might not be good enough for all purposes. The solver can do this division internally, which is more efficient than calling the solver multiple times as the LU decompositions only need to be formed once. internal_steps=1 means means that there is no substepping. Setting internal_steps=2 increases running time by roughly 25%. Each substep above 2 increases it by another 10-15% of the running time without substepping. See *** for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n_out[itot]</td><td>Final concentrations. Must be Pre-allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n0[itot]</td><td>Initial concentrations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_term[itot][source_order+1]</td><td>Polynomial coefficients s_i,j for the source term </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_order</td><td>Order of the source term polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_t</td><td>Length of the time step in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itot</td><td>The number of nuclides in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non</td><td>Number of reactions (inc. decay) in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non0[itot]</td><td>Number of parents for each nuclide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd[itot]</td><td>Number of decay parents for each nuclide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag[itot]</td><td>Diagonal elements of A, i.e., (-lambda_eff) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag[non]</td><td>Reaction specific decay constant of each reaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loc[non]</td><td>Index of the parent in each reaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_flux_step</td><td>Logical integer, is the flux zero? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_adjoint</td><td>Logical integer, is this adjoint calculation? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cram_order</td><td>Order of the CRAM approximation (just use 16). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_steps</td><td>Number of internal substeps to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_negatives</td><td>How to treat negative vaues in results: 0: Do nothing. 1: Remove all negative values. 2: Remove all negative values in forward mode. Remove all negative values in adjoint mode if source term is constant and both source and initial concentrations are non-negative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoff</td><td>Concentrations whose ABSOLUTE value is below cutoff times sum(abs(n_out)) are set to zero. This is applied after remove_negatives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZAI[itot]</td><td>ZAI identifiers of the nuclides.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indexing in loc must be in c style, i.e., starts from 0. Be avare of this when calling from Fortran.</dd>
<dd>
offdiag (which is called "a" in most of <a class="el" href="../../d5/dc1/namespace_origen.html">Origen</a> source code) and loc must be sorted in the special <a class="el" href="../../d5/dc1/namespace_origen.html">Origen</a> way:<ul>
<li>decay parents of first nuclide,</li>
<li>activation parents of first nuclide,</li>
<li>decay parents of second nuclide,</li>
<li>activation parents of the second,</li>
<li>and so on.</li>
</ul>
</dd>
<dd>
The culling feature from earlier versions was removed. Use internal substeps instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successfull exit or nonzero on failed exit. On failed exit the results (i.e., n) are unspecified. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d2/d99/tst_c_r_a_m_8cpp-example.html#a6">tstCRAM.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a246b07e575efe303e340da78c4e3e15c">CopyLU()</a>, <a class="el" href="../../d5/dc1/namespace_origen.html#acac5275310c6e0fef2672b821eb08e38">Origen::info()</a>, <a class="el" href="../../da/def/kernel__cram_8hpp.html#af79aa009834d9b4a50ef6fc96f89e5d7">kernel_cram_coefficients()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#aff5a005e75ba1c528c5f8597d45cb1cb">makeExpmInput()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a8109e19dd4e4009213d14ae3d68214f5">makeMatlabInput()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a47f2e62c0dbebc787052c165afcada0e">NAME</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a766915c86655672579fe5205b19bc692">OrigenToCRSMatrix()</a>, <a class="el" href="../../d8/dc8/_fake_factory_8cpp.html#a6deea1c2ba17f0529b284f5013940b9f">r</a>, and <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#af2e1575f3f81b75079edded741a589e3">SORT_NUCLIDES</a>.</p>

<p>Referenced by <a class="el" href="../../dd/d7e/kernel__cram__from__fortran_8cpp.html#aa6eba8d39329bf76318552b1837726b9">kernel_cram_from_fortran()</a>, and <a class="el" href="../../d4/d53/class_origen_1_1_solver__cram.html#a415be826c056e1634b7b7265380c27b3">Solver_cram::solve_impl()</a>.</p>

</div>
</div>
<a class="anchor" id="a766915c86655672579fe5205b19bc692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrigenToCRSMatrix </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p_a_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>p_a_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_diag_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p_a_nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_newIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_oldIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>p_src_dummy_n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>non0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zero_flux_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort_nuclides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert ORIGEN form input to regular compressed row storage (CRS) matrix representing the equivalent homogeneous equations.</p>
<p>This has two main functions:</p><ul>
<li>Build the actual coefficient matrix</li>
<li>Homogenize the equations (i.e., dn/dt = An +s ==&gt; dn'/dt = A'n')</li>
</ul>
<p>which are done simultaneously. In addition this:</p><ul>
<li>Allocates all diagonal elements (even zeros)</li>
<li>Sorts nuclides by ZAI</li>
<li>Sorts each row</li>
</ul>
<p>For details about the homogenization see: </p><hr/>
<dl class="section note"><dt>Note</dt><dd>The first nine arguments are used for output. They are pointers to the variables p_&lt;name in kernel_cram()&gt; The other arguments are same as for <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a>. The output, except for p_a_n and p_a_nnz which are scalars, will be allocated by this function. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d2/d99/tst_c_r_a_m_8cpp-example.html#a5">tstCRAM.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a9ce670e6925467c50c380d67ffe4dbd7">sortCRSnuclides()</a>.</p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
